---
title: boj 1182
comments: true
categories: problem_solving
tags: boj
---
```c++
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

int n,s,total,cnt;
int arr[20];
int bit[20];

void dfs(int c) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        if (bit[i])
            sum += arr[i];
    }
    if (sum == s) {
        cnt++;
        //return;
    }

	for (int i = c; i < n; i++) {
		bit[i] = 1;
		dfs(i + 1);
		bit[i] = 0;
	}
}

int main() {
    cin >> n >> s;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    dfs(0);
    if(s==0)
        cout << cnt-1 << '\n';
    else 
        cout << cnt << '\n';
    return 0;
}
```
### 해결 방법  
수열의 사이즈는 최대 20이므로 모든 경우의 수는 2^20 = 1048576으로 완전탐색으로 해결이 가능하다. arr 배열과 동일한 사이즈의 bit배열을 만들어서 비트 마스킹 방식과 유사하게 해결하였다. 
  
[swexpertacademy](https://swexpertacademy.com/main/main.do)의 `2817. 부분 수열의 합` 문제가 있다. 이 문제와 동일하지만, BOJ 문제는 전체 합이 0인 경우도 있어 모든 수열을 포함하지 않아서 합이 0이 되는 경우는 빼줘야 한다. 여러 방법이 있겠지만, s==0인 경우만 정답에서 1을 빼주었다.  



